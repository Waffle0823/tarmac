use std::{
    collections::BTreeMap,
    fs::File,
    io::{self, Write},
    path::{self, Path},
};

use crate::{data::SyncInput};

const TYPEGEN_HEADER: &str =
    "-- This file was @generated by Tarmac. It is not intended for manual editing.";

pub fn perform_typegen(output_path: Option<&Path>, inputs: &[&SyncInput]) -> io::Result<()> {
    if let Some(path) = output_path {
        typegen_grouped(path, inputs)
    } else {
        typegen_individual(inputs)
    }
}

enum GroupedItem<'a> {
    Folder {
        children_by_name: BTreeMap<String, GroupedItem<'a>>,
    },
    InputGroup {
        inputs_by_dpi_scale: BTreeMap<u32, &'a SyncInput>,
    },
}

fn typegen_grouped(output_path: &Path, inputs: &[&SyncInput]) -> io::Result<()> {
    let mut root_folder: BTreeMap<String, GroupedItem<'_>> = BTreeMap::new();

    for &input in inputs {
        if !input.config.codegen {
            continue;
        }

        let mut path_without_extension = input.path_without_dpi_scale.clone();
        path_without_extension.set_extension("");

        let relative_path = path_without_extension
            .strip_prefix(&input.config.codegen_base_path)
            .expect("Input base path was not a base path for input");

        let mut segments = Vec::new();
        for component in relative_path.components() {
            match component {
                path::Component::Prefix(_)
                | path::Component::RootDir
                | path::Component::Normal(_) => {
                    segments.push(component.as_os_str().to_str().unwrap())
                }
                path::Component::CurDir => {}
                path::Component::ParentDir => assert!(segments.pop().is_some()),
            }
        }

        let mut current_dir = &mut root_folder;
        for (i, &segment) in segments.iter().enumerate() {
            if i == segments.len() - 1 {
                let input_group = match current_dir.get_mut(segment) {
                    Some(existing) => existing,
                    None => {
                        let input_group = GroupedItem::InputGroup {
                            inputs_by_dpi_scale: BTreeMap::new(),
                        };
                        current_dir.insert(segment.to_owned(), input_group);
                        current_dir.get_mut(segment).unwrap()
                    }
                };

                if let GroupedItem::InputGroup {
                    inputs_by_dpi_scale,
                } = input_group
                {
                    inputs_by_dpi_scale.insert(input.dpi_scale, input);
                } else {
                    unreachable!();
                }
            } else {
                let next_entry =
                    current_dir
                        .entry(segment.to_owned())
                        .or_insert_with(|| GroupedItem::Folder {
                            children_by_name: BTreeMap::new(),
                        });

                if let GroupedItem::Folder { children_by_name } = next_entry {
                    current_dir = children_by_name;
                } else {
                    unreachable!();
                }
            }
        }
    }

    fn build_item(item: &GroupedItem<'_>, indent: usize) -> String {
        let indent_str = "  ".repeat(indent);

        match item {
            GroupedItem::Folder { children_by_name } => {
                let mut result = String::from("{\n");

                for (name, child) in children_by_name {
                    let child_type = build_item(child, indent + 1);
                    result.push_str(&format!(
                        "{}    readonly {}: {};\n",
                        indent_str, name, child_type
                    ));
                }

                result.push_str(&format!("{}}}", indent_str));
                result
            }
            GroupedItem::InputGroup { .. } => "string".to_string(),
        }
    }

    let root_type = build_item(
        &GroupedItem::Folder {
            children_by_name: root_folder,
        },
        0,
    );

    let mut file = File::create(output_path)?;
    writeln!(file, "{}", TYPEGEN_HEADER)?;
    writeln!(file)?;
    writeln!(file, "declare const assets: {};", root_type)?;
    writeln!(file)?;
    writeln!(file, "export = assets;")?;

    Ok(())
}

const IMAGE_SLICE_TYPE: &str = r#"
declare const value: {
    Image: string;
    ImageRectOffset: Vector2;
    ImageRectSize: Vector2;
};

export = value;
"#;

const JUST_ASSET_TYPE: &str = r#"
declare const value: string;
export = value;
"#;

fn typegen_individual(inputs: &[&SyncInput]) -> io::Result<()> {
    for input in inputs {
        let type_def = match (input.id, input.slice) {
            (Some(_), Some(_)) => IMAGE_SLICE_TYPE,
            (Some(_), None) => JUST_ASSET_TYPE,
            _ => continue,
        };

        let path = input.path.with_extension("d.ts");

        let mut file = File::create(path)?;
        writeln!(file, "{}", TYPEGEN_HEADER)?;
        write!(file, "{}", type_def)?;
    }

    Ok(())
}
